extern crate zmq;use std::env;use zmq::Message;use std::string::String;extern crate rusqlite;use rusqlite::Connection;use rusqlite::MappedRows;use rusqlite::Row;#[derive(Debug)]struct User {    pub id: i64,    name: String,}struct DB {    connection: Connection}impl DB {    pub fn new()->DB {        DB { connection:Connection::open("db.db").unwrap()}    }    pub fn getOrCreateUser(&self, data : String) -> User {        let mut stmt = self.connection.prepare("SELECT id, name FROM users where name = '?1' or name = ?1 limit 1").unwrap();        let user =stmt.query_row(&[&data],|row| {            User {                id: row.get(0),                name: row.get(1)            }        }).unwrap_or({            self.connection.execute("insert into users (name) values(?1);",&[&data]);            let id = self.connection.last_insert_rowid();            User {id:id, name:data}        });        return user;        /*        {            Ok(u) => {u},             => {                self.connection.execute("insert into users (name) values(?1);",&[&data]);                let id = self.connection.last_insert_rowid();                return User {id:id, name:data};            },        });        */    }}fn main() {    let channel = b"users-service";    let server_name =  (match  env::var("ZMQ_PUB_ADDRESS") {        Ok(v) => v,        Err(e) => String::from("tcp://127.0.0.1:3000")    });    let db = DB::new();    let context = zmq::Context::new();    let subscriber = context.socket(zmq::SUB).unwrap();    subscriber.set_subscribe(channel);    subscriber.connect(server_name.as_str());    loop {        let topic = subscriber.recv_msg(0).unwrap();        let data = subscriber.recv_string(0).expect("").unwrap();        let command = subscriber.recv_string(0).expect("").unwrap();        let item = db.getOrCreateUser(data);        println!("{} has id {}", item.name, item.id);    }}